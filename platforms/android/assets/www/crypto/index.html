<!DOCTYPE html>
<!-- saved from url=(0056)https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Crypto Node.js v5.2.0 Manual &amp; Documentation</title>
  <link rel="stylesheet" href="./Crypto Node.js v5.2.0 Manual & Documentation_files/css">
  <link rel="stylesheet" href="./Crypto Node.js v5.2.0 Manual & Documentation_files/style.css">
  <link rel="stylesheet" href="./Crypto Node.js v5.2.0 Manual & Documentation_files/sh.css">
  <link rel="canonical" href="https://nodejs.org/api/crypto.html">
</head>
<body class="alt apidoc" id="api-section-crypto">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="https://nodejs.org/" title="Go back to the home page">
          Node.js (1)
        </a>
      </div>
      <ul>
<li><a class="nav-documentation" href="https://nodejs.org/dist/latest-v5.x/docs/api/documentation.html">About these Docs</a></li>
<li><a class="nav-synopsis" href="https://nodejs.org/dist/latest-v5.x/docs/api/synopsis.html">Synopsis</a></li>
<li><a class="nav-assert" href="https://nodejs.org/dist/latest-v5.x/docs/api/assert.html">Assertion Testing</a></li>
<li><a class="nav-buffer" href="https://nodejs.org/dist/latest-v5.x/docs/api/buffer.html">Buffer</a></li>
<li><a class="nav-addons" href="https://nodejs.org/dist/latest-v5.x/docs/api/addons.html">C/C++ Addons</a></li>
<li><a class="nav-child_process" href="https://nodejs.org/dist/latest-v5.x/docs/api/child_process.html">Child Processes</a></li>
<li><a class="nav-cluster" href="https://nodejs.org/dist/latest-v5.x/docs/api/cluster.html">Cluster</a></li>
<li><a class="nav-console" href="https://nodejs.org/dist/latest-v5.x/docs/api/console.html">Console</a></li>
<li><a class="nav-crypto active" href="./Crypto Node.js v5.2.0 Manual & Documentation_files/Crypto Node.js v5.2.0 Manual & Documentation.html">Crypto</a></li>
<li><a class="nav-debugger" href="https://nodejs.org/dist/latest-v5.x/docs/api/debugger.html">Debugger</a></li>
<li><a class="nav-dns" href="https://nodejs.org/dist/latest-v5.x/docs/api/dns.html">DNS</a></li>
<li><a class="nav-domain" href="https://nodejs.org/dist/latest-v5.x/docs/api/domain.html">Domain</a></li>
<li><a class="nav-errors" href="https://nodejs.org/dist/latest-v5.x/docs/api/errors.html">Errors</a></li>
<li><a class="nav-events" href="https://nodejs.org/dist/latest-v5.x/docs/api/events.html">Events</a></li>
<li><a class="nav-fs" href="https://nodejs.org/dist/latest-v5.x/docs/api/fs.html">File System</a></li>
<li><a class="nav-globals" href="https://nodejs.org/dist/latest-v5.x/docs/api/globals.html">Globals</a></li>
<li><a class="nav-http" href="https://nodejs.org/dist/latest-v5.x/docs/api/http.html">HTTP</a></li>
<li><a class="nav-https" href="https://nodejs.org/dist/latest-v5.x/docs/api/https.html">HTTPS</a></li>
<li><a class="nav-modules" href="https://nodejs.org/dist/latest-v5.x/docs/api/modules.html">Modules</a></li>
<li><a class="nav-net" href="https://nodejs.org/dist/latest-v5.x/docs/api/net.html">Net</a></li>
<li><a class="nav-os" href="https://nodejs.org/dist/latest-v5.x/docs/api/os.html">OS</a></li>
<li><a class="nav-path" href="https://nodejs.org/dist/latest-v5.x/docs/api/path.html">Path</a></li>
<li><a class="nav-process" href="https://nodejs.org/dist/latest-v5.x/docs/api/process.html">Process</a></li>
<li><a class="nav-punycode" href="https://nodejs.org/dist/latest-v5.x/docs/api/punycode.html">Punycode</a></li>
<li><a class="nav-querystring" href="https://nodejs.org/dist/latest-v5.x/docs/api/querystring.html">Query Strings</a></li>
<li><a class="nav-readline" href="https://nodejs.org/dist/latest-v5.x/docs/api/readline.html">Readline</a></li>
<li><a class="nav-repl" href="https://nodejs.org/dist/latest-v5.x/docs/api/repl.html">REPL</a></li>
<li><a class="nav-stream" href="https://nodejs.org/dist/latest-v5.x/docs/api/stream.html">Stream</a></li>
<li><a class="nav-string_decoder" href="https://nodejs.org/dist/latest-v5.x/docs/api/string_decoder.html">String Decoder</a></li>
<li><a class="nav-timers" href="https://nodejs.org/dist/latest-v5.x/docs/api/timers.html">Timers</a></li>
<li><a class="nav-tls" href="https://nodejs.org/dist/latest-v5.x/docs/api/tls.html">TLS/SSL</a></li>
<li><a class="nav-tty" href="https://nodejs.org/dist/latest-v5.x/docs/api/tty.html">TTY</a></li>
<li><a class="nav-dgram" href="https://nodejs.org/dist/latest-v5.x/docs/api/dgram.html">UDP/Datagram</a></li>
<li><a class="nav-url" href="https://nodejs.org/dist/latest-v5.x/docs/api/url.html">URL</a></li>
<li><a class="nav-util" href="https://nodejs.org/dist/latest-v5.x/docs/api/util.html">Utilities</a></li>
<li><a class="nav-v8" href="https://nodejs.org/dist/latest-v5.x/docs/api/v8.html">V8</a></li>
<li><a class="nav-vm" href="https://nodejs.org/dist/latest-v5.x/docs/api/vm.html">VM</a></li>
<li><a class="nav-zlib" href="https://nodejs.org/dist/latest-v5.x/docs/api/zlib.html">ZLIB</a></li>
</ul>

    </div>

    <div id="column1" data-id="crypto" class="interior">
      <header>
        <h1>Node.js v5.2.0 Documentation</h1>
        <div id="gtoc">
          <p>
            <a href="https://nodejs.org/dist/latest-v5.x/docs/api/index.html" name="toc">Index</a> |
            <a href="https://nodejs.org/dist/latest-v5.x/docs/api/all.html">View on single page</a> |
            <a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.json">View as JSON</a>
          </p>
        </div>
        <hr>
      </header>

      <div id="toc">
        <h2>Table of Contents</h2>
        <ul>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto">Crypto</a><ul>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_certificate">Class: Certificate</a><ul>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_certificate_exportchallenge_spkac">Certificate.exportChallenge(spkac)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_certificate_exportpublickey_spkac">Certificate.exportPublicKey(spkac)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_certificate_verifyspkac_spkac">Certificate.verifySpkac(spkac)</a></li>
</ul>
</li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_cipher">Class: Cipher</a><ul>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_cipher_final_output_encoding">cipher.final([output_encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_cipher_getauthtag">cipher.getAuthTag()</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_cipher_setaad_buffer">cipher.setAAD(buffer)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_cipher_setautopadding_auto_padding_true">cipher.setAutoPadding(auto_padding=true)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_cipher_update_data_input_encoding_output_encoding">cipher.update(data[, input_encoding][, output_encoding])</a></li>
</ul>
</li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_decipher">Class: Decipher</a><ul>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_decipher_final_output_encoding">decipher.final([output_encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_decipher_setaad_buffer">decipher.setAAD(buffer)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_decipher_setauthtag_buffer">decipher.setAuthTag(buffer)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_decipher_setautopadding_auto_padding_true">decipher.setAutoPadding(auto_padding=true)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_decipher_update_data_input_encoding_output_encoding">decipher.update(data[, input_encoding][, output_encoding])</a></li>
</ul>
</li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_diffiehellman">Class: DiffieHellman</a><ul>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding">diffieHellman.computeSecret(other_public_key[, input_encoding][, output_encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_generatekeys_encoding">diffieHellman.generateKeys([encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_getgenerator_encoding">diffieHellman.getGenerator([encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_getprime_encoding">diffieHellman.getPrime([encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_getprivatekey_encoding">diffieHellman.getPrivateKey([encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_getpublickey_encoding">diffieHellman.getPublicKey([encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_setprivatekey_private_key_encoding">diffieHellman.setPrivateKey(private_key[, encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_setpublickey_public_key_encoding">diffieHellman.setPublicKey(public_key[, encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_verifyerror">diffieHellman.verifyError</a></li>
</ul>
</li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_ecdh">Class: ECDH</a><ul>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_ecdh_computesecret_other_public_key_input_encoding_output_encoding">ECDH.computeSecret(other_public_key[, input_encoding][, output_encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_ecdh_generatekeys_encoding_format">ECDH.generateKeys([encoding[, format]])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_ecdh_getprivatekey_encoding">ECDH.getPrivateKey([encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_ecdh_getpublickey_encoding_format">ECDH.getPublicKey([encoding[, format]])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_ecdh_setprivatekey_private_key_encoding">ECDH.setPrivateKey(private_key[, encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_ecdh_setpublickey_public_key_encoding">ECDH.setPublicKey(public_key[, encoding])</a></li>
</ul>
</li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_hash">Class: Hash</a><ul>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_hash_digest_encoding">hash.digest([encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_hash_update_data_input_encoding">hash.update(data[, input_encoding])</a></li>
</ul>
</li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_hmac">Class: Hmac</a><ul>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_hmac_digest_encoding">hmac.digest([encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_hmac_update_data">hmac.update(data)</a></li>
</ul>
</li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_sign">Class: Sign</a><ul>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_sign_sign_private_key_output_format">sign.sign(private_key[, output_format])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_sign_update_data">sign.update(data)</a></li>
</ul>
</li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_verify">Class: Verify</a><ul>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_verifier_update_data">verifier.update(data)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_verifier_verify_object_signature_signature_format">verifier.verify(object, signature[, signature_format])</a></li>
</ul>
</li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_default_encoding">crypto.DEFAULT_ENCODING</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createcipher_algorithm_password">crypto.createCipher(algorithm, password)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv">crypto.createCipheriv(algorithm, key, iv)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createcredentials_details">crypto.createCredentials(details)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createdecipher_algorithm_password">crypto.createDecipher(algorithm, password)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv">crypto.createDecipheriv(algorithm, key, iv)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_creatediffiehellman_prime_prime_encoding_generator_generator_encoding">crypto.createDiffieHellman(prime[, prime_encoding][, generator][, generator_encoding])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_creatediffiehellman_prime_length_generator">crypto.createDiffieHellman(prime_length[, generator])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createecdh_curve_name">crypto.createECDH(curve_name)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createhash_algorithm">crypto.createHash(algorithm)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createhmac_algorithm_key">crypto.createHmac(algorithm, key)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createsign_algorithm">crypto.createSign(algorithm)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createverify_algorithm">crypto.createVerify(algorithm)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_getciphers">crypto.getCiphers()</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_getcurves">crypto.getCurves()</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_getdiffiehellman_group_name">crypto.getDiffieHellman(group_name)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_gethashes">crypto.getHashes()</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback">crypto.pbkdf2(password, salt, iterations, keylen[, digest], callback)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest">crypto.pbkdf2Sync(password, salt, iterations, keylen[, digest])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_privatedecrypt_private_key_buffer">crypto.privateDecrypt(private_key, buffer)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_privateencrypt_private_key_buffer">crypto.privateEncrypt(private_key, buffer)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_publicdecrypt_public_key_buffer">crypto.publicDecrypt(public_key, buffer)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_publicencrypt_public_key_buffer">crypto.publicEncrypt(public_key, buffer)</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_randombytes_size_callback">crypto.randomBytes(size[, callback])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_setengine_engine_flags">crypto.setEngine(engine[, flags])</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_recent_api_changes">Recent API Changes</a></li>
<li><a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_caveats">Caveats</a></li>
</ul>
</li>
</ul>

      </div>

      <div id="apicontent">
        <h1>Crypto<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto" id="crypto_crypto">#</a></span></h1>
<pre class="api_stability_2 sh_sourceCode">Stability<span class="sh_symbol">:</span> <span class="sh_number">2</span> <span class="sh_symbol">-</span> Stable</pre><p>Use <code>require('crypto')</code> to access this module.

</p>
<p>The crypto module offers a way of encapsulating secure credentials to be
used as part of a secure HTTPS net or http connection.

</p>
<p>It also offers a set of wrappers for OpenSSL's hash, hmac, cipher,
decipher, sign and verify methods.

</p>
<h2>Class: Certificate<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_certificate" id="crypto_class_certificate">#</a></span></h2>
<p>The class used for working with signed public key &amp; challenges. The most
common usage for this series of functions is when dealing with the <code>&lt;keygen&gt;</code>
element. <a href="https://www.openssl.org/docs/apps/spkac.html">https://www.openssl.org/docs/apps/spkac.html</a>

</p>
<p>Returned by <code>crypto.Certificate</code>.

</p>
<h3>Certificate.exportChallenge(spkac)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_certificate_exportchallenge_spkac" id="crypto_certificate_exportchallenge_spkac">#</a></span></h3>
<p>Exports the encoded challenge associated with the SPKAC.

</p>
<h3>Certificate.exportPublicKey(spkac)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_certificate_exportpublickey_spkac" id="crypto_certificate_exportpublickey_spkac">#</a></span></h3>
<p>Exports the encoded public key from the supplied SPKAC.

</p>
<h3>Certificate.verifySpkac(spkac)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_certificate_verifyspkac_spkac" id="crypto_certificate_verifyspkac_spkac">#</a></span></h3>
<p>Returns true of false based on the validity of the SPKAC.

</p>
<h2>Class: Cipher<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_cipher" id="crypto_class_cipher">#</a></span></h2>
<p>Class for encrypting data.

</p>
<p>Returned by <code>crypto.createCipher</code> and <code>crypto.createCipheriv</code>.

</p>
<p>Cipher objects are <a href="https://nodejs.org/dist/latest-v5.x/docs/api/stream.html">streams</a> that are both readable and writable.
The written plain text data is used to produce the encrypted data on
the readable side. The legacy <code>update</code> and <code>final</code> methods are also
supported.

</p>
<h3>cipher.final([output_encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_cipher_final_output_encoding" id="crypto_cipher_final_output_encoding">#</a></span></h3>
<p>Returns any remaining enciphered contents, with <code>output_encoding</code>
being one of: <code>'binary'</code>, <code>'base64'</code> or <code>'hex'</code>.  If no encoding is
provided, then a buffer is returned.

</p>
<p>Note: <code>cipher</code> object can not be used after <code>final()</code> method has been
called.

</p>
<h3>cipher.getAuthTag()<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_cipher_getauthtag" id="crypto_cipher_getauthtag">#</a></span></h3>
<p>For authenticated encryption modes (currently supported: GCM), this
method returns a <code>Buffer</code> that represents the <em>authentication tag</em> that
has been computed from the given data. Should be called after
encryption has been completed using the <code>final</code> method!

</p>
<h3>cipher.setAAD(buffer)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_cipher_setaad_buffer" id="crypto_cipher_setaad_buffer">#</a></span></h3>
<p>For authenticated encryption modes (currently supported: GCM), this
method sets the value used for the additional authenticated data (AAD) input
parameter.

</p>
<h3>cipher.setAutoPadding(auto_padding=true)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_cipher_setautopadding_auto_padding_true" id="crypto_cipher_setautopadding_auto_padding_true">#</a></span></h3>
<p>You can disable automatic padding of the input data to block size. If
<code>auto_padding</code> is false, the length of the entire input data must be a
multiple of the cipher's block size or <code>final</code> will fail.  Useful for
non-standard padding, e.g. using <code>0x0</code> instead of PKCS padding. You
must call this before <code>cipher.final</code>.

</p>
<h3>cipher.update(data[, input_encoding][, output_encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_cipher_update_data_input_encoding_output_encoding" id="crypto_cipher_update_data_input_encoding_output_encoding">#</a></span></h3>
<p>Updates the cipher with <code>data</code>, the encoding of which is given in
<code>input_encoding</code> and can be <code>'utf8'</code>, <code>'ascii'</code> or <code>'binary'</code>.  If no
encoding is provided, then a buffer is expected.
If <code>data</code> is a <code>Buffer</code> then <code>input_encoding</code> is ignored.

</p>
<p>The <code>output_encoding</code> specifies the output format of the enciphered
data, and can be <code>'binary'</code>, <code>'base64'</code> or <code>'hex'</code>.  If no encoding is
provided, then a buffer is returned.

</p>
<p>Returns the enciphered contents, and can be called many times with new
data as it is streamed.

</p>
<h2>Class: Decipher<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_decipher" id="crypto_class_decipher">#</a></span></h2>
<p>Class for decrypting data.

</p>
<p>Returned by <a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createdecipher_algorithm_password"><code>crypto.createDecipher</code></a> and <a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv"><code>crypto.createDecipheriv</code></a>.

</p>
<p>Decipher objects are <a href="https://nodejs.org/dist/latest-v5.x/docs/api/stream.html">streams</a> that are both readable and writable.
The written enciphered data is used to produce the plain-text data on
the the readable side. The legacy <code>update</code> and <code>final</code> methods are also
supported.

</p>
<h3>decipher.final([output_encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_decipher_final_output_encoding" id="crypto_decipher_final_output_encoding">#</a></span></h3>
<p>Returns any remaining plaintext which is deciphered, with
<code>output_encoding</code> being one of: <code>'binary'</code>, <code>'ascii'</code> or <code>'utf8'</code>.  If
no encoding is provided, then a buffer is returned.

</p>
<p>Note: <code>decipher</code> object can not be used after <code>final()</code> method has been
called.

</p>
<h3>decipher.setAAD(buffer)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_decipher_setaad_buffer" id="crypto_decipher_setaad_buffer">#</a></span></h3>
<p>For authenticated encryption modes (currently supported: GCM), this
method sets the value used for the additional authenticated data (AAD) input
parameter.

</p>
<h3>decipher.setAuthTag(buffer)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_decipher_setauthtag_buffer" id="crypto_decipher_setauthtag_buffer">#</a></span></h3>
<p>For authenticated encryption modes (currently supported: GCM), this
method must be used to pass in the received <em>authentication tag</em>.
If no tag is provided or if the ciphertext has been tampered with,
<code>final</code> will throw, thus indicating that the ciphertext should
be discarded due to failed authentication.

</p>
<h3>decipher.setAutoPadding(auto_padding=true)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_decipher_setautopadding_auto_padding_true" id="crypto_decipher_setautopadding_auto_padding_true">#</a></span></h3>
<p>You can disable auto padding if the data has been encrypted without
standard block padding to prevent <code>decipher.final</code> from checking and
removing it. This will only work if the input data's length is a multiple of
the ciphers block size. You must call this before streaming data to
<a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_decipher_update_data_input_encoding_output_encoding"><code>decipher.update</code></a>.

</p>
<h3>decipher.update(data[, input_encoding][, output_encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_decipher_update_data_input_encoding_output_encoding" id="crypto_decipher_update_data_input_encoding_output_encoding">#</a></span></h3>
<p>Updates the decipher with <code>data</code>, which is encoded in <code>'binary'</code>,
<code>'base64'</code> or <code>'hex'</code>.  If no encoding is provided, then a buffer is
expected.
If <code>data</code> is a <code>Buffer</code> then <code>input_encoding</code> is ignored.

</p>
<p>The <code>output_decoding</code> specifies in what format to return the
deciphered plaintext: <code>'binary'</code>, <code>'ascii'</code> or <code>'utf8'</code>.  If no
encoding is provided, then a buffer is returned.

</p>
<h2>Class: DiffieHellman<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_diffiehellman" id="crypto_class_diffiehellman">#</a></span></h2>
<p>The class for creating Diffie-Hellman key exchanges.

</p>
<p>Returned by <code>crypto.createDiffieHellman</code>.

</p>
<h3>diffieHellman.computeSecret(other_public_key[, input_encoding][, output_encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding" id="crypto_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding">#</a></span></h3>
<p>Computes the shared secret using <code>other_public_key</code> as the other
party's public key and returns the computed shared secret. Supplied
key is interpreted using specified <code>input_encoding</code>, and secret is
encoded using specified <code>output_encoding</code>. Encodings can be
<code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. If the input encoding is not
provided, then a buffer is expected.

</p>
<p>If no output encoding is given, then a buffer is returned.

</p>
<h3>diffieHellman.generateKeys([encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_generatekeys_encoding" id="crypto_diffiehellman_generatekeys_encoding">#</a></span></h3>
<p>Generates private and public Diffie-Hellman key values, and returns
the public key in the specified encoding. This key should be
transferred to the other party. Encoding can be <code>'binary'</code>, <code>'hex'</code>,
or <code>'base64'</code>.  If no encoding is provided, then a buffer is returned.

</p>
<h3>diffieHellman.getGenerator([encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_getgenerator_encoding" id="crypto_diffiehellman_getgenerator_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman generator in the specified encoding, which can
be <code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. If no encoding is provided,
then a buffer is returned.

</p>
<h3>diffieHellman.getPrime([encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_getprime_encoding" id="crypto_diffiehellman_getprime_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman prime in the specified encoding, which can
be <code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. If no encoding is provided,
then a buffer is returned.

</p>
<h3>diffieHellman.getPrivateKey([encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_getprivatekey_encoding" id="crypto_diffiehellman_getprivatekey_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman private key in the specified encoding,
which can be <code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. If no encoding is
provided, then a buffer is returned.

</p>
<h3>diffieHellman.getPublicKey([encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_getpublickey_encoding" id="crypto_diffiehellman_getpublickey_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman public key in the specified encoding, which
can be <code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. If no encoding is provided,
then a buffer is returned.

</p>
<h3>diffieHellman.setPrivateKey(private_key[, encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_setprivatekey_private_key_encoding" id="crypto_diffiehellman_setprivatekey_private_key_encoding">#</a></span></h3>
<p>Sets the Diffie-Hellman private key. Key encoding can be <code>'binary'</code>,
<code>'hex'</code> or <code>'base64'</code>. If no encoding is provided, then a buffer is
expected.

</p>
<h3>diffieHellman.setPublicKey(public_key[, encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_setpublickey_public_key_encoding" id="crypto_diffiehellman_setpublickey_public_key_encoding">#</a></span></h3>
<p>Sets the Diffie-Hellman public key. Key encoding can be <code>'binary'</code>,
<code>'hex'</code> or <code>'base64'</code>. If no encoding is provided, then a buffer is
expected.

</p>
<h3>diffieHellman.verifyError<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_verifyerror" id="crypto_diffiehellman_verifyerror">#</a></span></h3>
<p>A bit field containing any warnings and/or errors as a result of a check performed
during initialization. The following values are valid for this property
(defined in <code>constants</code> module):

</p>
<ul>
<li><code>DH_CHECK_P_NOT_SAFE_PRIME</code></li>
<li><code>DH_CHECK_P_NOT_PRIME</code></li>
<li><code>DH_UNABLE_TO_CHECK_GENERATOR</code></li>
<li><code>DH_NOT_SUITABLE_GENERATOR</code></li>
</ul>
<h2>Class: ECDH<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_ecdh" id="crypto_class_ecdh">#</a></span></h2>
<p>The class for creating EC Diffie-Hellman key exchanges.

</p>
<p>Returned by <code>crypto.createECDH</code>.

</p>
<h3>ECDH.computeSecret(other_public_key[, input_encoding][, output_encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_ecdh_computesecret_other_public_key_input_encoding_output_encoding" id="crypto_ecdh_computesecret_other_public_key_input_encoding_output_encoding">#</a></span></h3>
<p>Computes the shared secret using <code>other_public_key</code> as the other
party's public key and returns the computed shared secret. Supplied
key is interpreted using specified <code>input_encoding</code>, and secret is
encoded using specified <code>output_encoding</code>. Encodings can be
<code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. If the input encoding is not
provided, then a buffer is expected.

</p>
<p>If no output encoding is given, then a buffer is returned.

</p>
<h3>ECDH.generateKeys([encoding[, format]])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_ecdh_generatekeys_encoding_format" id="crypto_ecdh_generatekeys_encoding_format">#</a></span></h3>
<p>Generates private and public EC Diffie-Hellman key values, and returns
the public key in the specified format and encoding. This key should be
transferred to the other party.

</p>
<p>Format specifies point encoding and can be <code>'compressed'</code>, <code>'uncompressed'</code>, or
<code>'hybrid'</code>. If no format is provided - the point will be returned in
<code>'uncompressed'</code> format.

</p>
<p>Encoding can be <code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. If no encoding is provided,
then a buffer is returned.

</p>
<h3>ECDH.getPrivateKey([encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_ecdh_getprivatekey_encoding" id="crypto_ecdh_getprivatekey_encoding">#</a></span></h3>
<p>Returns the EC Diffie-Hellman private key in the specified encoding,
which can be <code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. If no encoding is
provided, then a buffer is returned.

</p>
<h3>ECDH.getPublicKey([encoding[, format]])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_ecdh_getpublickey_encoding_format" id="crypto_ecdh_getpublickey_encoding_format">#</a></span></h3>
<p>Returns the EC Diffie-Hellman public key in the specified encoding and format.

</p>
<p>Format specifies point encoding and can be <code>'compressed'</code>, <code>'uncompressed'</code>, or
<code>'hybrid'</code>. If no format is provided - the point will be returned in
<code>'uncompressed'</code> format.

</p>
<p>Encoding can be <code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. If no encoding is provided,
then a buffer is returned.

</p>
<h3>ECDH.setPrivateKey(private_key[, encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_ecdh_setprivatekey_private_key_encoding" id="crypto_ecdh_setprivatekey_private_key_encoding">#</a></span></h3>
<p>Sets the EC Diffie-Hellman private key. Key encoding can be <code>'binary'</code>,
<code>'hex'</code> or <code>'base64'</code>. If no encoding is provided, then a buffer is
expected. If <code>private_key</code> is not valid for the curve specified when
the ECDH object was created, then an error is thrown. Upon setting
the private key, the associated public point (key) is also generated
and set in the ECDH object.

</p>
<h3>ECDH.setPublicKey(public_key[, encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_ecdh_setpublickey_public_key_encoding" id="crypto_ecdh_setpublickey_public_key_encoding">#</a></span></h3>
<pre class="api_stability_0 sh_sourceCode">Stability<span class="sh_symbol">:</span> <span class="sh_number">0</span> <span class="sh_symbol">-</span> Deprecated</pre><p>Sets the EC Diffie-Hellman public key. Key encoding can be <code>'binary'</code>,
<code>'hex'</code> or <code>'base64'</code>. If no encoding is provided, then a buffer is
expected. Note that there is not normally a reason to call this
method. This is because ECDH only needs your private key and the
other party's public key to compute the shared secret. Thus, usually
either <code>generateKeys</code> or <code>setPrivateKey</code> will be called.
Note that <code>setPrivateKey</code> attempts to generate the public point/key
associated with the private key being set.

</p>
<p>Example (obtaining a shared secret):

</p>
<pre class="sh_sourceCode"><code><span class="sh_keyword">var</span> crypto <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'crypto'</span><span class="sh_symbol">);</span>
<span class="sh_keyword">var</span> alice <span class="sh_symbol">=</span> crypto<span class="sh_symbol">.</span><span class="sh_function">createECDH</span><span class="sh_symbol">(</span><span class="sh_string">'secp256k1'</span><span class="sh_symbol">);</span>
<span class="sh_keyword">var</span> bob <span class="sh_symbol">=</span> crypto<span class="sh_symbol">.</span><span class="sh_function">createECDH</span><span class="sh_symbol">(</span><span class="sh_string">'secp256k1'</span><span class="sh_symbol">);</span>

<span class="sh_comment">// Note: This is a shortcut way to specify one of Alice's previous private</span>
<span class="sh_comment">// keys. It would be unwise to use such a predictable private key in a real</span>
<span class="sh_comment">// application.</span>
alice<span class="sh_symbol">.</span><span class="sh_function">setPrivateKey</span><span class="sh_symbol">(</span>
  crypto<span class="sh_symbol">.</span><span class="sh_function">createHash</span><span class="sh_symbol">(</span><span class="sh_string">'sha256'</span><span class="sh_symbol">).</span><span class="sh_function">update</span><span class="sh_symbol">(</span><span class="sh_string">'alice'</span><span class="sh_symbol">,</span> <span class="sh_string">'utf8'</span><span class="sh_symbol">).</span><span class="sh_function">digest</span><span class="sh_symbol">()</span>
<span class="sh_symbol">);</span>

<span class="sh_comment">// Bob uses a newly generated cryptographically strong pseudorandom key pair</span>
bob<span class="sh_symbol">.</span><span class="sh_function">generateKeys</span><span class="sh_symbol">();</span>

<span class="sh_keyword">var</span> alice_secret <span class="sh_symbol">=</span> alice<span class="sh_symbol">.</span><span class="sh_function">computeSecret</span><span class="sh_symbol">(</span>bob<span class="sh_symbol">.</span><span class="sh_function">getPublicKey</span><span class="sh_symbol">(),</span> <span class="sh_keyword">null</span><span class="sh_symbol">,</span> <span class="sh_string">'hex'</span><span class="sh_symbol">);</span>
<span class="sh_keyword">var</span> bob_secret <span class="sh_symbol">=</span> bob<span class="sh_symbol">.</span><span class="sh_function">computeSecret</span><span class="sh_symbol">(</span>alice<span class="sh_symbol">.</span><span class="sh_function">getPublicKey</span><span class="sh_symbol">(),</span> <span class="sh_keyword">null</span><span class="sh_symbol">,</span> <span class="sh_string">'hex'</span><span class="sh_symbol">);</span>

<span class="sh_comment">// alice_secret and bob_secret should be the same shared secret value</span>
console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>alice_secret <span class="sh_symbol">===</span> bob_secret<span class="sh_symbol">);</span></code></pre>
<h2>Class: Hash<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_hash" id="crypto_class_hash">#</a></span></h2>
<p>The class for creating hash digests of data.

</p>
<p>It is a <a href="https://nodejs.org/dist/latest-v5.x/docs/api/stream.html">stream</a> that is both readable and writable.  The written data
is used to compute the hash.  Once the writable side of the stream is ended,
use the <code>read()</code> method to get the computed hash digest.  The legacy <code>update</code>
and <code>digest</code> methods are also supported.

</p>
<p>Returned by <code>crypto.createHash</code>.

</p>
<h3>hash.digest([encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_hash_digest_encoding" id="crypto_hash_digest_encoding">#</a></span></h3>
<p>Calculates the digest of all of the passed data to be hashed.  The
<code>encoding</code> can be <code>'hex'</code>, <code>'binary'</code> or <code>'base64'</code>.  If no encoding
is provided, then a buffer is returned.

</p>
<p>Note: <code>hash</code> object can not be used after <code>digest()</code> method has been
called.

</p>
<h3>hash.update(data[, input_encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_hash_update_data_input_encoding" id="crypto_hash_update_data_input_encoding">#</a></span></h3>
<p>Updates the hash content with the given <code>data</code>, the encoding of which
is given in <code>input_encoding</code> and can be <code>'utf8'</code>, <code>'ascii'</code> or
<code>'binary'</code>.  If no encoding is provided, and the input is a string, an
encoding of <code>'binary'</code> is enforced. If <code>data</code> is a <code>Buffer</code> then
<code>input_encoding</code> is ignored.

</p>
<p>This can be called many times with new data as it is streamed.

</p>
<h2>Class: Hmac<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_hmac" id="crypto_class_hmac">#</a></span></h2>
<p>Class for creating cryptographic hmac content.

</p>
<p>Returned by <code>crypto.createHmac</code>.

</p>
<h3>hmac.digest([encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_hmac_digest_encoding" id="crypto_hmac_digest_encoding">#</a></span></h3>
<p>Calculates the digest of all of the passed data to the hmac.  The
<code>encoding</code> can be <code>'hex'</code>, <code>'binary'</code> or <code>'base64'</code>.  If no encoding
is provided, then a buffer is returned.

</p>
<p>Note: <code>hmac</code> object can not be used after <code>digest()</code> method has been
called.

</p>
<h3>hmac.update(data)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_hmac_update_data" id="crypto_hmac_update_data">#</a></span></h3>
<p>Update the hmac content with the given <code>data</code>.  This can be called
many times with new data as it is streamed.

</p>
<h2>Class: Sign<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_sign" id="crypto_class_sign">#</a></span></h2>
<p>Class for generating signatures.

</p>
<p>Returned by <code>crypto.createSign</code>.

</p>
<p>Sign objects are writable <a href="https://nodejs.org/dist/latest-v5.x/docs/api/stream.html">streams</a>.  The written data is used to
generate the signature.  Once all of the data has been written, the
<code>sign</code> method will return the signature.  The legacy <code>update</code> method
is also supported.

</p>
<h3>sign.sign(private_key[, output_format])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_sign_sign_private_key_output_format" id="crypto_sign_sign_private_key_output_format">#</a></span></h3>
<p>Calculates the signature on all the updated data passed through the
sign.

</p>
<p><code>private_key</code> can be an object or a string. If <code>private_key</code> is a string, it is
treated as the key with no passphrase.

</p>
<p><code>private_key</code>:

</p>
<ul>
<li><code>key</code> : A string holding the PEM encoded private key</li>
<li><code>passphrase</code> : A string of passphrase for the private key</li>
</ul>
<p>Returns the signature in <code>output_format</code> which can be <code>'binary'</code>,
<code>'hex'</code> or <code>'base64'</code>. If no encoding is provided, then a buffer is
returned.

</p>
<p>Note: <code>sign</code> object can not be used after <code>sign()</code> method has been
called.

</p>
<h3>sign.update(data)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_sign_update_data" id="crypto_sign_update_data">#</a></span></h3>
<p>Updates the sign object with data.  This can be called many times
with new data as it is streamed.

</p>
<h2>Class: Verify<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_class_verify" id="crypto_class_verify">#</a></span></h2>
<p>Class for verifying signatures.

</p>
<p>Returned by <code>crypto.createVerify</code>.

</p>
<p>Verify objects are writable <a href="https://nodejs.org/dist/latest-v5.x/docs/api/stream.html">streams</a>.  The written data is used to
validate against the supplied signature.  Once all of the data has been
written, the <code>verify</code> method will return true if the supplied signature
is valid.  The legacy <code>update</code> method is also supported.

</p>
<h3>verifier.update(data)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_verifier_update_data" id="crypto_verifier_update_data">#</a></span></h3>
<p>Updates the verifier object with data.  This can be called many times
with new data as it is streamed.

</p>
<h3>verifier.verify(object, signature[, signature_format])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_verifier_verify_object_signature_signature_format" id="crypto_verifier_verify_object_signature_signature_format">#</a></span></h3>
<p>Verifies the signed data by using the <code>object</code> and <code>signature</code>.
<code>object</code> is  a string containing a PEM encoded object, which can be
one of RSA public key, DSA public key, or X.509 certificate.
<code>signature</code> is the previously calculated signature for the data, in
the <code>signature_format</code> which can be <code>'binary'</code>, <code>'hex'</code> or <code>'base64'</code>.
If no encoding is specified, then a buffer is expected.

</p>
<p>Returns true or false depending on the validity of the signature for
the data and public key.

</p>
<p>Note: <code>verifier</code> object can not be used after <code>verify()</code> method has been
called.

</p>
<h2>crypto.DEFAULT_ENCODING<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_default_encoding" id="crypto_crypto_default_encoding">#</a></span></h2>
<p>The default encoding to use for functions that can take either strings
or buffers.  The default value is <code>'buffer'</code>, which makes it default
to using Buffer objects.  This is here to make the crypto module more
easily compatible with legacy programs that expected <code>'binary'</code> to be
the default encoding.

</p>
<p>Note that new programs will probably expect buffers, so only use this
as a temporary measure.

</p>
<h2>crypto.createCipher(algorithm, password)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createcipher_algorithm_password" id="crypto_crypto_createcipher_algorithm_password">#</a></span></h2>
<p>Creates and returns a cipher object, with the given algorithm and
password.

</p>
<p><code>algorithm</code> is dependent on OpenSSL, examples are <code>'aes192'</code>, etc.  On
recent releases, <code>openssl list-cipher-algorithms</code> will display the
available cipher algorithms.  <code>password</code> is used to derive key and IV,
which must be a <code>'binary'</code> encoded string or a <a href="https://nodejs.org/dist/latest-v5.x/docs/api/buffer.html">buffer</a>.

</p>
<p>It is a <a href="https://nodejs.org/dist/latest-v5.x/docs/api/stream.html">stream</a> that is both readable and writable.  The written data
is used to compute the hash.  Once the writable side of the stream is ended,
use the <code>read()</code> method to get the enciphered contents.  The legacy <code>update</code>
and <code>final</code> methods are also supported.

</p>
<p>Note: <code>createCipher</code> derives keys with the OpenSSL function <a href="https://www.openssl.org/docs/crypto/EVP_BytesToKey.html"><code>EVP_BytesToKey</code></a>
with the digest algorithm set to MD5, one iteration, and no salt. The lack of
salt allows dictionary attacks as the same password always creates the same key.
The low iteration count and non-cryptographically secure hash algorithm allow
passwords to be tested very rapidly.

</p>
<p>In line with OpenSSL's recommendation to use pbkdf2 instead of <a href="https://www.openssl.org/docs/crypto/EVP_BytesToKey.html"><code>EVP_BytesToKey</code></a> it
is recommended you derive a key and iv yourself with <a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback"><code>crypto.pbkdf2</code></a> and to
then use <a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv"><code>createCipheriv()</code></a> to create the cipher stream.

</p>
<h2>crypto.createCipheriv(algorithm, key, iv)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv" id="crypto_crypto_createcipheriv_algorithm_key_iv">#</a></span></h2>
<p>Creates and returns a cipher object, with the given algorithm, key and
iv.

</p>
<p><code>algorithm</code> is the same as the argument to <code>createCipher()</code>.  <code>key</code> is
the raw key used by the algorithm.  <code>iv</code> is an <a href="https://en.wikipedia.org/wiki/Initialization_vector">initialization vector</a>.

</p>
<p><code>key</code> and <code>iv</code> must be <code>'binary'</code> encoded strings or <a href="https://nodejs.org/dist/latest-v5.x/docs/api/buffer.html">buffers</a>.

</p>
<h2>crypto.createCredentials(details)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createcredentials_details" id="crypto_crypto_createcredentials_details">#</a></span></h2>
<pre class="api_stability_0 sh_sourceCode">Stability<span class="sh_symbol">:</span> <span class="sh_number">0</span> <span class="sh_symbol">-</span> Deprecated<span class="sh_symbol">:</span> Use <a href="https://nodejs.org/dist/latest-v5.x/docs/api/tls.html#tls_tls_createsecurecontext_details"><code>tls<span class="sh_symbol">.</span>createSecureContext</code></a> instead<span class="sh_symbol">.</span></pre><p>Creates a credentials object, with the optional details being a
dictionary with keys:

</p>
<ul>
<li><code>pfx</code> : A string or buffer holding the PFX or PKCS12 encoded private
key, certificate and CA certificates</li>
<li><code>key</code> : A string holding the PEM encoded private key</li>
<li><code>passphrase</code> : A string of passphrase for the private key or pfx</li>
<li><code>cert</code> : A string holding the PEM encoded certificate</li>
<li><code>ca</code> : Either a string or list of strings of PEM encoded CA
certificates to trust.</li>
<li><code>crl</code> : Either a string or list of strings of PEM encoded CRLs
(Certificate Revocation List)</li>
<li><code>ciphers</code>: A string describing the ciphers to use or exclude.
Consult
<a href="https://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">https://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>
for details on the format.</li>
</ul>
<p>If no 'ca' details are given, then Node.js will use the default
publicly trusted list of CAs as given in
</p>
<p><a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.

</p>
<h2>crypto.createDecipher(algorithm, password)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createdecipher_algorithm_password" id="crypto_crypto_createdecipher_algorithm_password">#</a></span></h2>
<p>Creates and returns a decipher object, with the given algorithm and
key.  This is the mirror of the <a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createcipher_algorithm_password"><code>createCipher()</code></a> above.

</p>
<h2>crypto.createDecipheriv(algorithm, key, iv)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv" id="crypto_crypto_createdecipheriv_algorithm_key_iv">#</a></span></h2>
<p>Creates and returns a decipher object, with the given algorithm, key
and iv.  This is the mirror of the <a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv"><code>createCipheriv()</code></a> above.

</p>
<h2>crypto.createDiffieHellman(prime[, prime_encoding][, generator][, generator_encoding])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_creatediffiehellman_prime_prime_encoding_generator_generator_encoding" id="crypto_crypto_creatediffiehellman_prime_prime_encoding_generator_generator_encoding">#</a></span></h2>
<p>Creates a Diffie-Hellman key exchange object using the supplied <code>prime</code> and an
optional specific <code>generator</code>.
<code>generator</code> can be a number, string, or Buffer.
If no <code>generator</code> is specified, then <code>2</code> is used.
<code>prime_encoding</code> and <code>generator_encoding</code> can be <code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>.
If no <code>prime_encoding</code> is specified, then a Buffer is expected for <code>prime</code>.
If no <code>generator_encoding</code> is specified, then a Buffer is expected for <code>generator</code>.

</p>
<h2>crypto.createDiffieHellman(prime_length[, generator])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_creatediffiehellman_prime_length_generator" id="crypto_crypto_creatediffiehellman_prime_length_generator">#</a></span></h2>
<p>Creates a Diffie-Hellman key exchange object and generates a prime of
<code>prime_length</code> bits and using an optional specific numeric <code>generator</code>.
If no <code>generator</code> is specified, then <code>2</code> is used.

</p>
<h2>crypto.createECDH(curve_name)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createecdh_curve_name" id="crypto_crypto_createecdh_curve_name">#</a></span></h2>
<p>Creates an Elliptic Curve (EC) Diffie-Hellman key exchange object using a
predefined curve specified by the <code>curve_name</code> string. Use <a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_getcurves"><code>getCurves()</code></a> to
obtain a list of available curve names. On recent releases,
<code>openssl ecparam -list_curves</code> will also display the name and description of
each available elliptic curve.

</p>
<h2>crypto.createHash(algorithm)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createhash_algorithm" id="crypto_crypto_createhash_algorithm">#</a></span></h2>
<p>Creates and returns a hash object, a cryptographic hash with the given
algorithm which can be used to generate hash digests.

</p>
<p><code>algorithm</code> is dependent on the available algorithms supported by the
version of OpenSSL on the platform. Examples are <code>'sha256'</code>,
<code>'sha512'</code>, etc.  On recent releases, <code>openssl
list-message-digest-algorithms</code> will display the available digest
algorithms.

</p>
<p>Example: this program that takes the sha256 sum of a file

</p>
<pre class="sh_sourceCode"><code><span class="sh_keyword">var</span> filename <span class="sh_symbol">=</span> process<span class="sh_symbol">.</span>argv<span class="sh_symbol">[</span><span class="sh_number">2</span><span class="sh_symbol">];</span>
<span class="sh_keyword">var</span> crypto <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'crypto'</span><span class="sh_symbol">);</span>
<span class="sh_keyword">var</span> fs <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'fs'</span><span class="sh_symbol">);</span>

<span class="sh_keyword">var</span> shasum <span class="sh_symbol">=</span> crypto<span class="sh_symbol">.</span><span class="sh_function">createHash</span><span class="sh_symbol">(</span><span class="sh_string">'sha256'</span><span class="sh_symbol">);</span>

<span class="sh_keyword">var</span> s <span class="sh_symbol">=</span> fs<span class="sh_symbol">.</span><span class="sh_function">ReadStream</span><span class="sh_symbol">(</span>filename<span class="sh_symbol">);</span>
s<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'data'</span><span class="sh_symbol">,</span> <span class="sh_keyword">function</span><span class="sh_symbol">(</span>d<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
  shasum<span class="sh_symbol">.</span><span class="sh_function">update</span><span class="sh_symbol">(</span>d<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>

s<span class="sh_symbol">.</span><span class="sh_function">on</span><span class="sh_symbol">(</span><span class="sh_string">'end'</span><span class="sh_symbol">,</span> <span class="sh_keyword">function</span><span class="sh_symbol">()</span> <span class="sh_cbracket">{</span>
  <span class="sh_keyword">var</span> d <span class="sh_symbol">=</span> shasum<span class="sh_symbol">.</span><span class="sh_function">digest</span><span class="sh_symbol">(</span><span class="sh_string">'hex'</span><span class="sh_symbol">);</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>d <span class="sh_symbol">+</span> <span class="sh_string">'  '</span> <span class="sh_symbol">+</span> filename<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span></code></pre>
<h2>crypto.createHmac(algorithm, key)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createhmac_algorithm_key" id="crypto_crypto_createhmac_algorithm_key">#</a></span></h2>
<p>Creates and returns a hmac object, a cryptographic hmac with the given
algorithm and key.

</p>
<p>It is a <a href="https://nodejs.org/dist/latest-v5.x/docs/api/stream.html">stream</a> that is both readable and writable.  The written
data is used to compute the hmac.  Once the writable side of the
stream is ended, use the <code>read()</code> method to get the computed digest.
The legacy <code>update</code> and <code>digest</code> methods are also supported.

</p>
<p><code>algorithm</code> is dependent on the available algorithms supported by
OpenSSL - see createHash above.  <code>key</code> is the hmac key to be used.

</p>
<h2>crypto.createSign(algorithm)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createsign_algorithm" id="crypto_crypto_createsign_algorithm">#</a></span></h2>
<p>Creates and returns a signing object, with the given algorithm.  On
recent OpenSSL releases, <code>openssl list-public-key-algorithms</code> will
display the available signing algorithms. Examples are <code>'RSA-SHA256'</code>.

</p>
<h2>crypto.createVerify(algorithm)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_createverify_algorithm" id="crypto_crypto_createverify_algorithm">#</a></span></h2>
<p>Creates and returns a verification object, with the given algorithm.
This is the mirror of the signing object above.

</p>
<h2>crypto.getCiphers()<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_getciphers" id="crypto_crypto_getciphers">#</a></span></h2>
<p>Returns an array with the names of the supported ciphers.

</p>
<p>Example:

</p>
<pre class="sh_sourceCode"><code><span class="sh_keyword">var</span> ciphers <span class="sh_symbol">=</span> crypto<span class="sh_symbol">.</span><span class="sh_function">getCiphers</span><span class="sh_symbol">();</span>
console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>ciphers<span class="sh_symbol">);</span> <span class="sh_comment">// ['aes-128-cbc', 'aes-128-ccm', ...]</span></code></pre>
<h2>crypto.getCurves()<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_getcurves" id="crypto_crypto_getcurves">#</a></span></h2>
<p>Returns an array with the names of the supported elliptic curves.

</p>
<p>Example:

</p>
<pre class="sh_sourceCode"><code><span class="sh_keyword">var</span> curves <span class="sh_symbol">=</span> crypto<span class="sh_symbol">.</span><span class="sh_function">getCurves</span><span class="sh_symbol">();</span>
console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>curves<span class="sh_symbol">);</span> <span class="sh_comment">// ['secp256k1', 'secp384r1', ...]</span></code></pre>
<h2>crypto.getDiffieHellman(group_name)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_getdiffiehellman_group_name" id="crypto_crypto_getdiffiehellman_group_name">#</a></span></h2>
<p>Creates a predefined Diffie-Hellman key exchange object.  The
supported groups are: <code>'modp1'</code>, <code>'modp2'</code>, <code>'modp5'</code> (defined in
<a href="https://www.rfc-editor.org/rfc/rfc2412.txt">RFC 2412</a>, but see <a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_caveats">Caveats</a>) and <code>'modp14'</code>, <code>'modp15'</code>,
<code>'modp16'</code>, <code>'modp17'</code>, <code>'modp18'</code> (defined in <a href="https://www.rfc-editor.org/rfc/rfc3526.txt">RFC 3526</a>).  The
returned object mimics the interface of objects created by
<a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_creatediffiehellman_prime_prime_encoding_generator_generator_encoding"><code>crypto.createDiffieHellman()</code></a> above, but will not allow changing
the keys (with <a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_diffiehellman_setpublickey_public_key_encoding"><code>diffieHellman.setPublicKey()</code></a> for example). The
advantage of using this routine is that the parties do not have to
generate nor exchange group modulus beforehand, saving both processor
and communication time.

</p>
<p>Example (obtaining a shared secret):

</p>
<pre class="sh_sourceCode"><code><span class="sh_keyword">var</span> crypto <span class="sh_symbol">=</span> <span class="sh_function">require</span><span class="sh_symbol">(</span><span class="sh_string">'crypto'</span><span class="sh_symbol">);</span>
<span class="sh_keyword">var</span> alice <span class="sh_symbol">=</span> crypto<span class="sh_symbol">.</span><span class="sh_function">getDiffieHellman</span><span class="sh_symbol">(</span><span class="sh_string">'modp14'</span><span class="sh_symbol">);</span>
<span class="sh_keyword">var</span> bob <span class="sh_symbol">=</span> crypto<span class="sh_symbol">.</span><span class="sh_function">getDiffieHellman</span><span class="sh_symbol">(</span><span class="sh_string">'modp14'</span><span class="sh_symbol">);</span>

alice<span class="sh_symbol">.</span><span class="sh_function">generateKeys</span><span class="sh_symbol">();</span>
bob<span class="sh_symbol">.</span><span class="sh_function">generateKeys</span><span class="sh_symbol">();</span>

<span class="sh_keyword">var</span> alice_secret <span class="sh_symbol">=</span> alice<span class="sh_symbol">.</span><span class="sh_function">computeSecret</span><span class="sh_symbol">(</span>bob<span class="sh_symbol">.</span><span class="sh_function">getPublicKey</span><span class="sh_symbol">(),</span> <span class="sh_keyword">null</span><span class="sh_symbol">,</span> <span class="sh_string">'hex'</span><span class="sh_symbol">);</span>
<span class="sh_keyword">var</span> bob_secret <span class="sh_symbol">=</span> bob<span class="sh_symbol">.</span><span class="sh_function">computeSecret</span><span class="sh_symbol">(</span>alice<span class="sh_symbol">.</span><span class="sh_function">getPublicKey</span><span class="sh_symbol">(),</span> <span class="sh_keyword">null</span><span class="sh_symbol">,</span> <span class="sh_string">'hex'</span><span class="sh_symbol">);</span>

<span class="sh_comment">/* alice_secret and bob_secret should be the same */</span>
console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>alice_secret <span class="sh_symbol">==</span> bob_secret<span class="sh_symbol">);</span></code></pre>
<h2>crypto.getHashes()<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_gethashes" id="crypto_crypto_gethashes">#</a></span></h2>
<p>Returns an array with the names of the supported hash algorithms.

</p>
<p>Example:

</p>
<pre class="sh_sourceCode"><code><span class="sh_keyword">var</span> hashes <span class="sh_symbol">=</span> crypto<span class="sh_symbol">.</span><span class="sh_function">getHashes</span><span class="sh_symbol">();</span>
console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>hashes<span class="sh_symbol">);</span> <span class="sh_comment">// ['sha', 'sha1', 'sha1WithRSAEncryption', ...]</span></code></pre>
<h2>crypto.pbkdf2(password, salt, iterations, keylen[, digest], callback)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback" id="crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback">#</a></span></h2>
<p>Asynchronous PBKDF2 function.  Applies the selected HMAC digest function
(default: SHA1) to derive a key of the requested byte length from the password,
salt and number of iterations.  The callback gets two arguments:
<code>(err, derivedKey)</code>.

</p>
<p>The number of iterations passed to pbkdf2 should be as high as possible, the
higher the number, the more secure it will be, but will take a longer amount of
time to complete.

</p>
<p>Chosen salts should also be unique. It is recommended that the salts are random
and their length is greater than 16 bytes. See <a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf">NIST SP 800-132</a> for details.

</p>
<p>Example:

</p>
<pre class="sh_sourceCode"><code>crypto<span class="sh_symbol">.</span><span class="sh_function">pbkdf2</span><span class="sh_symbol">(</span><span class="sh_string">'secret'</span><span class="sh_symbol">,</span> <span class="sh_string">'salt'</span><span class="sh_symbol">,</span> <span class="sh_number">100000</span><span class="sh_symbol">,</span> <span class="sh_number">512</span><span class="sh_symbol">,</span> <span class="sh_string">'sha512'</span><span class="sh_symbol">,</span> <span class="sh_keyword">function</span><span class="sh_symbol">(</span>err<span class="sh_symbol">,</span> key<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
  <span class="sh_keyword">if</span> <span class="sh_symbol">(</span>err<span class="sh_symbol">)</span>
    <span class="sh_keyword">throw</span> err<span class="sh_symbol">;</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span>key<span class="sh_symbol">.</span><span class="sh_function">toString</span><span class="sh_symbol">(</span><span class="sh_string">'hex'</span><span class="sh_symbol">));</span>  <span class="sh_comment">// 'c5e478d...1469e50'</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span></code></pre>
<p>You can get a list of supported digest functions with <a href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_gethashes"><code>crypto.getHashes()</code></a>.

</p>
<h2>crypto.pbkdf2Sync(password, salt, iterations, keylen[, digest])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest" id="crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest">#</a></span></h2>
<p>Synchronous PBKDF2 function.  Returns derivedKey or throws error.

</p>
<h2>crypto.privateDecrypt(private_key, buffer)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_privatedecrypt_private_key_buffer" id="crypto_crypto_privatedecrypt_private_key_buffer">#</a></span></h2>
<p>Decrypts <code>buffer</code> with <code>private_key</code>.

</p>
<p><code>private_key</code> can be an object or a string. If <code>private_key</code> is a string, it is
treated as the key with no passphrase and will use <code>RSA_PKCS1_OAEP_PADDING</code>.

</p>
<p><code>private_key</code>:

</p>
<ul>
<li><code>key</code> : A string holding the PEM encoded private key</li>
<li><code>passphrase</code> : An optional string of passphrase for the private key</li>
<li><code>padding</code> : An optional padding value, one of the following:<ul>
<li><code>constants.RSA_NO_PADDING</code></li>
<li><code>constants.RSA_PKCS1_PADDING</code></li>
<li><code>constants.RSA_PKCS1_OAEP_PADDING</code></li>
</ul>
</li>
</ul>
<p>NOTE: All paddings are defined in <code>constants</code> module.

</p>
<h2>crypto.privateEncrypt(private_key, buffer)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_privateencrypt_private_key_buffer" id="crypto_crypto_privateencrypt_private_key_buffer">#</a></span></h2>
<p>See above for details. Has the same API as <code>crypto.privateDecrypt</code>.
Default padding is <code>RSA_PKCS1_PADDING</code>.

</p>
<h2>crypto.publicDecrypt(public_key, buffer)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_publicdecrypt_public_key_buffer" id="crypto_crypto_publicdecrypt_public_key_buffer">#</a></span></h2>
<p>See above for details. Has the same API as <code>crypto.publicEncrypt</code>. Default
padding is <code>RSA_PKCS1_PADDING</code>.

</p>
<h2>crypto.publicEncrypt(public_key, buffer)<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_publicencrypt_public_key_buffer" id="crypto_crypto_publicencrypt_public_key_buffer">#</a></span></h2>
<p>Encrypts <code>buffer</code> with <code>public_key</code>. Only RSA is currently supported.

</p>
<p><code>public_key</code> can be an object or a string. If <code>public_key</code> is a string, it is
treated as the key with no passphrase and will use <code>RSA_PKCS1_OAEP_PADDING</code>.
Since RSA public keys may be derived from private keys you may pass a private
key to this method.

</p>
<p><code>public_key</code>:

</p>
<ul>
<li><code>key</code> : A string holding the PEM encoded private key</li>
<li><code>passphrase</code> : An optional string of passphrase for the private key</li>
<li><code>padding</code> : An optional padding value, one of the following:<ul>
<li><code>constants.RSA_NO_PADDING</code></li>
<li><code>constants.RSA_PKCS1_PADDING</code></li>
<li><code>constants.RSA_PKCS1_OAEP_PADDING</code></li>
</ul>
</li>
</ul>
<p>NOTE: All paddings are defined in <code>constants</code> module.

</p>
<h2>crypto.randomBytes(size[, callback])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_randombytes_size_callback" id="crypto_crypto_randombytes_size_callback">#</a></span></h2>
<p>Generates cryptographically strong pseudo-random data. Usage:

</p>
<pre class="sh_sourceCode"><code><span class="sh_comment">// async</span>
crypto<span class="sh_symbol">.</span><span class="sh_function">randomBytes</span><span class="sh_symbol">(</span><span class="sh_number">256</span><span class="sh_symbol">,</span> <span class="sh_keyword">function</span><span class="sh_symbol">(</span>ex<span class="sh_symbol">,</span> buf<span class="sh_symbol">)</span> <span class="sh_cbracket">{</span>
  <span class="sh_keyword">if</span> <span class="sh_symbol">(</span>ex<span class="sh_symbol">)</span> <span class="sh_keyword">throw</span> ex<span class="sh_symbol">;</span>
  console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'Have %d bytes of random data: %s'</span><span class="sh_symbol">,</span> buf<span class="sh_symbol">.</span>length<span class="sh_symbol">,</span> buf<span class="sh_symbol">);</span>
<span class="sh_cbracket">}</span><span class="sh_symbol">);</span>

<span class="sh_comment">// sync</span>
<span class="sh_keyword">const</span> buf <span class="sh_symbol">=</span> crypto<span class="sh_symbol">.</span><span class="sh_function">randomBytes</span><span class="sh_symbol">(</span><span class="sh_number">256</span><span class="sh_symbol">);</span>
console<span class="sh_symbol">.</span><span class="sh_function">log</span><span class="sh_symbol">(</span><span class="sh_string">'Have %d bytes of random data: %s'</span><span class="sh_symbol">,</span> buf<span class="sh_symbol">.</span>length<span class="sh_symbol">,</span> buf<span class="sh_symbol">);</span></code></pre>
<p>NOTE: This will block if there is insufficient entropy, although it should
normally never take longer than a few milliseconds. The only time when this
may conceivably block is right after boot, when the whole system is still
low on entropy.

</p>
<h2>crypto.setEngine(engine[, flags])<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_crypto_setengine_engine_flags" id="crypto_crypto_setengine_engine_flags">#</a></span></h2>
<p>Load and set engine for some/all OpenSSL functions (selected by flags).

</p>
<p><code>engine</code> could be either an id or a path to the engine's shared library.

</p>
<p><code>flags</code> is optional and has <code>ENGINE_METHOD_ALL</code> value by default. It could take
one of or mix of following flags (defined in <code>constants</code> module):

</p>
<ul>
<li><code>ENGINE_METHOD_RSA</code></li>
<li><code>ENGINE_METHOD_DSA</code></li>
<li><code>ENGINE_METHOD_DH</code></li>
<li><code>ENGINE_METHOD_RAND</code></li>
<li><code>ENGINE_METHOD_ECDH</code></li>
<li><code>ENGINE_METHOD_ECDSA</code></li>
<li><code>ENGINE_METHOD_CIPHERS</code></li>
<li><code>ENGINE_METHOD_DIGESTS</code></li>
<li><code>ENGINE_METHOD_STORE</code></li>
<li><code>ENGINE_METHOD_PKEY_METH</code></li>
<li><code>ENGINE_METHOD_PKEY_ASN1_METH</code></li>
<li><code>ENGINE_METHOD_ALL</code></li>
<li><code>ENGINE_METHOD_NONE</code></li>
</ul>
<h2>Recent API Changes<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_recent_api_changes" id="crypto_recent_api_changes">#</a></span></h2>
<p>The Crypto module was added to Node.js before there was the concept of a
unified Stream API, and before there were Buffer objects for handling
binary data.

</p>
<p>As such, the streaming classes don't have the typical methods found on
other Node.js classes, and many methods accepted and returned
Binary-encoded strings by default rather than Buffers.  This was
changed to use Buffers by default instead.

</p>
<p>This is a breaking change for some use cases, but not all.

</p>
<p>For example, if you currently use the default arguments to the Sign
class, and then pass the results to the Verify class, without ever
inspecting the data, then it will continue to work as before.  Where
you once got a binary string and then presented the binary string to
the Verify object, you'll now get a Buffer, and present the Buffer to
the Verify object.

</p>
<p>However, if you were doing things with the string data that will not
work properly on Buffers (such as, concatenating them, storing in
databases, etc.), or you are passing binary strings to the crypto
functions without an encoding argument, then you will need to start
providing encoding arguments to specify which encoding you'd like to
use.  To switch to the previous style of using binary strings by
default, set the <code>crypto.DEFAULT_ENCODING</code> field to 'binary'.  Note
that new programs will probably expect buffers, so only use this as a
temporary measure.

</p>
<p>Usage of <code>ECDH</code> with non-dynamically generated key pairs has been simplified.
Now, <code>setPrivateKey</code> can be called with a preselected private key and the
associated public point (key) will be computed and stored in the object.
This allows you to only store and provide the private part of the EC key pair.
<code>setPrivateKey</code> now also validates that the private key is valid for the curve.
<code>ECDH.setPublicKey</code> is now deprecated as its inclusion in the API is not
useful. Either a previously stored private key should be set, which
automatically generates the associated public key, or <code>generateKeys</code> should be
called. The main drawback of <code>ECDH.setPublicKey</code> is that it can be used to put
the ECDH key pair into an inconsistent state.

</p>
<h2>Caveats<span><a class="mark" href="https://nodejs.org/dist/latest-v5.x/docs/api/crypto.html#crypto_caveats" id="crypto_caveats">#</a></span></h2>
<p>The crypto module still supports some algorithms which are already
compromised. And the API also allows the use of ciphers and hashes
with a small key size that are considered to be too weak for safe use.

</p>
<p>Users should take full responsibility for selecting the crypto
algorithm and key size according to their security requirements.

</p>
<p>Based on the recommendations of <a href="http://csrc.nist.gov/publications/nistpubs/800-131A/sp800-131A.pdf">NIST SP 800-131A</a>:

</p>
<ul>
<li>MD5 and SHA-1 are no longer acceptable where collision resistance is
required such as digital signatures.</li>
<li>The key used with RSA, DSA and DH algorithms is recommended to have
at least 2048 bits and that of the curve of ECDSA and ECDH at least
224 bits, to be safe to use for several years.</li>
<li>The DH groups of <code>modp1</code>, <code>modp2</code> and <code>modp5</code> have a key size
smaller than 2048 bits and are not recommended.</li>
</ul>
<p>See the reference for other recommendations and details.

</p>

      </div>
    </div>
  </div>
  <div id="footer">
  </div>

  <script src="./Crypto Node.js v5.2.0 Manual & Documentation_files/sh_main.js"></script>
  <script src="./Crypto Node.js v5.2.0 Manual & Documentation_files/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>



</body></html>